# JUnit 5

## MudanÃ§as
O JUnit 5 (antigamente chamado de JUnit lambda) Ã© uma revisÃ£o do projeto, adicionando novas funcionalidades suportadas pelo Java8. O projeto foi separado em diferentes mÃ³dulos e garante compatibilidade com as versÃµes anteriores.

Os novos mÃ³dulos do JUnit sÃ£o:

- JUnit Platform: Ã© a fundaÃ§Ã£o do framework de teste que contÃ©m as funcionalidades para execuÃ§Ã£o de testes e pontos de extensÃ£o para construÃ§Ã£o de plugins maven, gradle e etc;
- JUnit Jupiter: a nova plataforma do JUnit;
- JUnit Vintage: provÃª um TestEngine para execuÃ§Ã£o do JUnit 3 e 4;


## ConfiguraÃ§Ã£o
Para adicionar o JUnit 5 utilizando o Maven, devemos adicionar como dependÃªncia a nova plataforma:

    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.0.0</version>
        <scope>test</scope>
    </dependency>

E adicionalmente, devemos configurar o plugin do surefire.

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.19</version>
                <dependencies>
                    <dependency>
                        <groupId>org.junit.platform</groupId>
                        <artifactId>junit-platform-surefire-provider</artifactId>
                        <version>1.0.0</version>
                    </dependency>
                    <dependency>
                        <groupId>org.junit.jupiter</groupId>
                        <artifactId>junit-jupiter-engine</artifactId>
                        <version>5.0.0</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>

### Executando testes do JUnit 4 e Junit 5
Para executar testes do JUnit 4 junto aos do JUnit 5 Ã© necessÃ¡rio adicionar a dependÃªncia ao mÃ³dulo `junit-vintage-engine` e adicionar a dependÃªncia do JUnit 4 ao projeto.

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.19</version>
                <dependencies>
                    <dependency>
                        <groupId>org.junit.platform</groupId>
                        <artifactId>junit-platform-surefire-provider</artifactId>
                        <version>1.1.0</version>
                    </dependency>
                    <dependency>
                        <groupId>org.junit.jupiter</groupId>
                        <artifactId>junit-jupiter-engine</artifactId>
                        <version>5.0.0</version>
                    </dependency>
                    <dependency>
                        <groupId>org.junit.vintage</groupId>
                        <artifactId>junit-vintage-engine</artifactId>
                        <version>4.12.0</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>

### Filtrando por Tags
Podemos filtrar os testes de acordo com suas tags (veja [Tags e Filtros](#tags-e-filtros))

    <build>
        <plugins>
            ...
            <plugin>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.19</version>
                <configuration>
                    <properties>
                        <includeTags>acceptance</includeTags>
                        <excludeTags>integration,regression</excludeTags>
                    </properties>
                </configuration>
                <dependencies>
                    ...
                </dependencies>
            </plugin>
        </plugins>
    </build>

### Junit Launcher
Ã‰ uma ferramenta de linha de comando [disponÃ­vel no maven](https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/) que provÃª pretty printing para a execuÃ§Ã£o de testes.

    â”œâ”€ JUnit Vintage
    â”‚  â””â”€ example.JUnit4Tests
    â”‚     â””â”€ standardJUnit4Test âœ”
    â””â”€ JUnit Jupiter
    â”œâ”€ StandardTests
    â”‚  â”œâ”€ succeedingTest() âœ”
    â”‚  â””â”€ skippedTest() â†· for demonstration purposes
    â””â”€ A special test case
        â”œâ”€ Custom test name containing spaces âœ”
        â”œâ”€ â•¯Â°â–¡Â°ï¼‰â•¯ âœ”
        â””â”€ ðŸ˜± âœ”

    Test run finished after 64 ms
    [         5 containers found      ]
    [         0 containers skipped    ]
    [         5 containers started    ]
    [         0 containers aborted    ]
    [         5 containers successful ]
    [         0 containers failed     ]
    [         6 tests found           ]
    [         1 tests skipped         ]
    [         5 tests started         ]
    [         0 tests aborted         ]
    [         5 tests successful      ]
    [         0 tests failed          ]

Mais sobre o [Runner](http://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher)

### Mais sobre ExecuÃ§Ã£o de Testes
Mais sobre configuraÃ£o seÃ§Ã£o especÃ­fica da [documentaÃ§ao](http://junit.org/junit5/docs/current/user-guide/#running-tests).

## Testes
### AnotaÃ§Ãµes
As principais anotaÃ§Ãµes do JUnit estÃ£o em `org.junit.jupiter.api`. algumas das anotaÃ§Ãµes antigas tiveram seu comportamento alterado como Ã© o caso da `@Test`.

AnotaÃ§Ã£o | DescriÃ§Ã£o
-----------|------------
@Test | Denotes that a method is a test method. Unlike JUnit 4â€™s @Test annotation, this annotation does not declare any attributes, since test extensions in JUnit Jupiter operate based on their own dedicated annotations. Such methods are inherited unless they are overridden.
@ParameterizedTest | Denotes that a method is a parameterized test. Such methods are inherited unless they are overridden.
@RepeatedTest | Denotes that a method is a test template for a repeated test. Such methods are inherited unless they are overridden.
@TestFactory | Denotes that a method is a test factory for dynamic tests. Such methods are inherited unless they are overridden.
@TestInstance | Used to configure the test instance lifecycle for the annotated test class. Such annotations are inherited.
@TestTemplate | Denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers. Such methods are inherited unless they are overridden.
@DisplayName | Declares a custom display name for the test class or test method. Such annotations are not inherited.
@BeforeEach | Denotes that the annotated method should be executed before each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4â€™s @Before. Such methods are inherited unless they are overridden.
@AfterEach | Denotes that the annotated method should be executed after each @Test, @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current class; analogous to JUnit 4â€™s @After. Such methods are inherited unless they are overridden.
@BeforeAll | Denotes that the annotated method should be executed before all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4â€™s @BeforeClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the "per-class" test instance lifecycle is used).
@AfterAll | Denotes that the annotated method should be executed after all @Test, @RepeatedTest, @ParameterizedTest, and @TestFactory methods in the current class; analogous to JUnit 4â€™s @AfterClass. Such methods are inherited (unless they are hidden or overridden) and must be static (unless the "per-class" test instance lifecycle is used).
@Nested | Denotes that the annotated class is a nested, non-static test class. @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test class unless the "per-class" test instance lifecycle is used. Such annotations are not inherited.
@Tag | Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.
@Disabled | Used to disable a test class or test method; analogous to JUnit 4â€™s @Ignore. Such annotations are not inherited.
@ExtendWith | Used to register custom extensions. Such annotations are inherited.

#### Meta-anotaÃ§Ãµes e anotaÃ§Ãµes compostas
Diferente das antigas versÃµes, cada teste poderÃ¡ ser anotado com diversas anotaÃ§Ãµes para definir seu comportamento. Em alguns casos, existem anotaÃ§Ãµes que se repetem diversas vezes pelas SuÃ­tes de Teste.

Para evitar repetiÃ§Ã£o de cÃ³digo o JUnit 5 permite que uma anotaÃ§Ã£o composta seja definida, onde configuraremos as anotaÃ§Ãµes que desejamos adicionar aos nossos testes (portanto, comportam-se como meta-anotaÃ§Ãµes). Ao anotar um teste com esta nova anotaÃ§Ã£o composta, este irÃ¡ herdar o comportamento de todas as anotaÃ§Ãµes associadas simultÃ¢neamente.


    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;

    import org.junit.jupiter.api.Tag;

    @Target({ ElementType.TYPE, ElementType.METHOD })
    @Retention(RetentionPolicy.RUNTIME)
    @Tag("fast")
    public @interface Fast { }

### Classe de Teste Exemplo
A estrutura padrÃ£o de um Teste com o JUnit 5 Ã©:

    class StandardTests {

        @BeforeAll
        static void initAll() {
        }

        @BeforeEach
        void init() {
        }

        @Test
        void succeedingTest() {
        }

        @Test
        void failingTest() {
            fail("a failing test");
        }

        @Test
        @Disabled("for demonstration purposes")
        void skippedTest() {
            // not executed
        }

        @AfterEach
        void tearDown() {
        }

        @AfterAll
        static void tearDownAll() {
        }

    }

### Nomes de ExibiÃ§Ã£o
Ã‰ possÃ­vel definir nomes de exibiÃ§Ã£o para os testes utilizando a anotaÃ§ao `@DisplayName`. Finalmente, BDD de graÃ§a!

    @DisplayName("A special test case")
    class DisplayNameDemo {

        @Test
        @DisplayName("Custom test name containing spaces")
        void testWithDisplayNameContainingSpaces() {
        }

        // More tests

    }

### Assertions
As principais mudanÃ§as das asserÃ§Ãµes sÃ£o 1) as mensagens agora sÃ£o o Ãºltimo parÃ¢metro, finalmente e 2) uso intensivo de lambdas.

#### Mensagens
No teste abaixo, note que Ã© possÃ­vel criar uma mensagem que serÃ¡ avaliada de maneira lazy, apenase se o teste falhar.

    class AssertionsDemo {

        @Test
        void standardAssertions() {
            assertEquals(2, 2);
            assertEquals(4, 4, "The optional assertion message is   now the last parameter.");
            assertTrue(2 == 2, () -> "Assertion messages can be     lazily evaluated -- "
                    + "to avoid constructing complex messages   unnecessarily.");
        }

        // More Tests

    }

#### AssertAll
HÃ¡ uma nova asserÃ§Ã£o chamada `assertAll` que recebe uma lista de asserÃ§Ãµes. Todas as asserÃ§Ãµes sÃ£o executadas e, se existirem, todas as falhas serÃ£o reportadas.

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and any
        // failures will be reported together.
        assertAll("person",
            () -> assertEquals("John", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

Ã‰ possÃ­vel criar estruturas complexas utilizando o `assertAll`.

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("n"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

#### Exceptions
Para avaliarmos se uma `Exception` Ã© lanÃ§ada, agora utilizamos o assert `assertThrows`. A vantagem deste novo mÃ©todo Ã© que obtemos a instÃ¢ncia da exceÃ§Ã£o, o que permite que avaliemos mensagens e outros dados.

    @Test
    void exceptionTesting() {
        Throwable exception = assertThrows(IllegalArgumentException.class, () -> {
            throw new IllegalArgumentException("a message");
        });
        assertEquals("a message", exception.getMessage());
    }


#### Timeout
Existem um novo assert para avaliar o tempo de resposta de um procedimento, `assertTimeout`.

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

### Assumptions
Assumptions Ã© um recurso antigo do JUnit 4 que tambÃ©m foi melhorado nesta nova versÃ£o. Uma Assumption Ã© uma teste utilizado para garantir que o ambiente do teste Ã© adequado e, caso contrÃ¡rio, o teste serÃ¡ ignorado. Este Ã© um recurso Ãºtil para verificar configuraÃ§Ãµes externas ou outros detalhes que possam causar a quebra do teste mas que nÃ£o possuam relaÃ§Ã£o com o estÃ¡ sendo testado em si (uma conexÃ£o com o BD, por exemplo).

    class AssumptionsDemo {

        @Test
        void testOnlyOnCiServer() {
            assumeTrue("CI".equals(System.getenv("ENV")));
            // remainder of test
        }

        // More tests

    }

Todas as Assumptions sÃ£o mÃ©todos estÃ¡ticos. Mais em [documentaÃ§Ã£o de usuario](http://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions) e todos os mÃ©todos listados no [javadoc](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html)

### Desabilitando testes
Desligamos testes com a anotaÃ§Ã£o `@Disabled`, que pode ser aplicada em classes ou mÃ©todos.

    @Disabled
    class DisabledClassDemo {
        @Test
        void testWillBeSkipped() {
        }
    }


### Tags e Filtros
Podemos utilizar a anotaÃ§Ã£o `Tag()` para aplicar tags em um teste. Estas tags sÃ£o Ãºteis para que testes sejam filtrados posteriormente.

    @Tag("fast")
    @Tag("model")
    class TaggingDemo {

        @Test
        @Tag("taxes")
        void testingTaxCalculation() {
        }

    }

Os nomes das Tags devem obedecer Ã s seguintes regras:
- NÃ¢o podem ser `null` ou um texto vazio;
- NÃ£o deve conter espaÃ§o em branco
- NÃ£o de conter caracteres de controle ISO
- NÃ£o deve conter os caracteres reservados `,`, `(`, `)`, `&`, `|`, `!`;

### Ciclo de vida da instÃ¢ncia do Teste
Como nas versÃµes anteriores, o comportamento default do JUnit Ã© que uma nova instÃ¢ncia da classe de testes seja criada Ã  cada teste, garantindo que estes sejam executados em isolamento.

No entanto, para casos em que todos os testes devam ser executados na mesma instÃ¢ncia, podemos anota a classe de teste com a nova anotaÃ§Ã£o `@TestInstance(Lifecycle.PER_CLASS)`.

Existem algumas opÃ§Ãµes com relaÃ§Ã£o Ã  esta configuraÃ§Ã£o, veja [na documentaÃ§Ã£o](http://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle-changing-default)

### Teste aninhados
Ã‰ possÃ­vel aninhar classes de teste, expressando melhor o relacionamento entre elas. Este aninhamento de classes pode ter uma profundidade arbitrÃ¡ria e, junto com os nomes indicados na anotaÃ§Ã£o `@DisplayName` pode criar uma Ã¡rvore de asserÃ§Ãµes com grande semÃ¢ntica.

    public class ListaTest {

        private List<String> lista;

        @Test
        @DisplayName("deve criar nova lista com new ArrayList()")
        void deveCriarNovaLista() {
            lista = new ArrayList<>();
        }

        @Nested
        @DisplayName("quando nova lista")
        class quandoNovaLista {

            @BeforeEach
            void setUp() {
                lista = new ArrayList<>();
            }

            @Test
            @DisplayName("deve estar vazia")
            void deveEstarVazia() {
                assertTrue(lista.isEmpty(), () -> "A lista nÃ£o estÃ¡     vazia! => " + lista);
            }

            @Test
            @DisplayName("deve adicionar novos valores com add")
            void deveAdicionarValoresComAdd() {
                lista.add("valor");
                assertFalse(lista.isEmpty(), () -> "A lista estÃ¡    vazia apÃ³s inserir um valor => " + lista);
            }

            @Nested
            @DisplayName("apÃ³s adicionar um valor")
            class quandoPossuiValores {

                @BeforeEach
                void setUp() {
                    lista.add("valor1");
                    lista.add("valor2");
                    lista.add("valor3");
                }

                @DisplayName("deve retornar o nÃºmero de elementos")
                @Test
                void deveRetornarONÃºmeroDeElementos() {
                    assertEquals(3, lista.size());
                }
            }

        }
    }

### InjeÃ§Ã£o de dependÃªncias para Construtores e MÃ©todos
O Junit 5 permite que construtores e metodos possuem argumentos , permitindo uma maior flexibilidade e permite que injeÃ§Ã£o de dependÃªncias seja habilitada para construtores e mÃ©todos.

Qualquer mÃ©todo anotado com `@Test`, `@TestFactory`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, ou `@AfterAll` Ã© candidato Ã  injeÃ§Ã£o de dependÃªncias.

O [ParameterResolver](http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/extension/ParameterResolver.html) do JUnit define a API para que extensÃµes de teste sejam desenvolvidas (frameworks). Estes `ParameterResolver` customizados, uma vez registrados permitem que diferentes instÃ¢ncias sejam injetadas. Um exemplo, Ã© a versÃ£o nova do Mockito:

    @ExtendWith(MockitoExtension.class)
    class MyMockitoTest {

        @BeforeEach
        void init(@Mock Person person) {
            when(person.getName()).thenReturn("Dilbert");
        }

        @Test
        void simpleTestWithInjectedMock(@Mock Person person) {
            assertEquals("Dilbert", person.getName());
        }

    }

Por padrÃ£o, o JUnit jÃ¡ disponibiliza os seguintes objetos:

Tipo | DescriÃ§Ã£o
-----|----------
TestInfo | ProvÃª informaÃ§Ãµes reflexivas sobre o prÃ³prio teste como, por exemplo, seu nome de display e outros dados.
RepetitionInfo | Para os mÃ©todos que repetem-se ( os anotados com `@RepeatedTest`, `@BeforeEach`, ou `@AfterEach`) Ã© possÃ­vel injetar o tipo `RepetitionInfo` que possui os dados da repetiÃ§Ã£o atual e quantidade de repetiÃ§Ãµes.
TestReporter | Objeto que provÃª a possibilidade de inserir mais informaÃ§Ãµes sobre o teste. Qualquer lugar onde imprimirÃ­amos dados para o `stdout` ou `stderr` devemos utilizar objeto.

DemonstraÃ§Ã£o de uso do `TestInfo`:

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

Podemos utilizar o `TestReporter` da seguinte forma:

    class TestReporterDemo {

        @Test
        void reportSingleValue(TestReporter testReporter) {
            testReporter.publishEntry("a key", "a value");
        }

        @Test
        void reportSeveralValues(TestReporter testReporter) {
            HashMap<String, String> values = new HashMap<>();
            values.put("user name", "dk38");
            values.put("award year", "1974");

            testReporter.publishEntry(values);
        }

    }

Na execuÃ§Ã£o, serÃ¡ impresso "timestamp = 2017-09-16T12:53:21.366, user name = dk38, award year = 1974'. TambÃ©m Ã© possÃ­vel chamar o mÃ©todo `publicEntry` adicionando uma chave e valor, da seguinte forma:

    testReporter.publishEntry(chave, valor);

O detalhe Ã© que, internamente, usa-se tambÃ©m um map e, quando adicionados desta forma, os valores serÃ£o exibidos separadamente:

    timestamp = 2017-09-16T12:57:11.752, 1 = valor1
    timestamp = 2017-09-16T12:57:11.755, 2 = valor2
    timestamp = 2017-09-16T12:57:11.755, 3 = valor3

### Test Interfaces e MÃ©todos Default
Ã‰ possÃ­vel declarar` @Test`, @`RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, `@TestTemplate`, `@BeforeEach`, e `@AfterEach` em mÃ©todos estÃ¡ticos ou default em interfaces. As anotaÃ§Ãµes `@BeforeAll` e `@AfterAll` tambÃ©m podem ser usadas como estÃ¡ticas desde que a classe esteja anotada com `@TestInstance(Lifecycle.PER_CLASS)` (veja [Ciclo de vida da instÃ¢ncia do Teste](#ciclo-de-vida-da-instÃ¢ncia-do-teste))

Esta funcionalidade Ã© Ãºtil para que possamos aplicar testes padrÃ£o e construir contratos com os quais determinados objetos deverÃ£o estar em conformidade, estabelecer padrÃµes de mensagens de teste, verificaÃ§Ã£o de tempo de execuÃ§Ã£o e etc.

    @TestInstance(Lifecycle.PER_CLASS)
    interface TestLifecycleLogger {

        static final Logger LOG = Logger.getLogger  (TestLifecycleLogger.class.getName());

        @BeforeAll
        default void beforeAllTests() {
            LOG.info("Before all tests");
        }

        @AfterAll
        default void afterAllTests() {
            LOG.info("After all tests");
        }

        @BeforeEach
        default void beforeEachTest(TestInfo testInfo) {
            LOG.info(() -> String.format("About to execute [%s]",
                testInfo.getDisplayName()));
        }

        @AfterEach
        default void afterEachTest(TestInfo testInfo) {
            LOG.info(() -> String.format("Finished executing [%s]",
                testInfo.getDisplayName()));
        }

    }

Podemos tambÃ©m declarar extensÃµes e tags em interfaces e estes serÃ£o herdados pelas classes que as implementarem.

    @Tag("timed")
    @ExtendWith(TimingExtension.class)
    interface TimeExecutionLogger { }

Em nossa classe:

    class TestInterfaceDemo implements TestLifecycleLogger,
            TimeExecutionLogger, TestInterfaceDynamicTestsDemo {

        @Test
        void isEqualValue() {
            assertEquals(1, 1, "is always equal");
        }

    }

Esta classe irÃ¡ herdar todos os detalhes da interface. Isto Ã©

### Testes com RepetiÃ§Ã£o
Ã‰ possÃ­vel repetir um teste diversas vezes atravÃ©s da anotaÃ§Ã£o `@RepeatedTest`, passando a quantidade de vezes que o teste deve ser repetir. O teste abaixo, irÃ¡ se repetir 10 vezes.

    @RepeatedTest(10)
    void repeatedTest() {
        // ...
    }

Podemos definir um nome de exibiÃ§Ã£o para as repetiÃ§Ãµes atravÃ©s do atributo `name` da anotaÃ§Ã£o `@RepeatedTest`. Existem alguns  placeholders que podemos utilizar para ajudar na identificaÃ§Ã£o:

- {displayName}: nome do teste
- {currentRepetition}: repetiÃ§Ã£o atual
- {totalRepetitions}: total de repetiÃ§Ãµes.

O nome default para este tipo de testes serÃ£ "repetition {currentRepetition} of {totalRepetitions}". Para ter acesso Ã  estes dados programaticamente, Ã© possÃ­vel injetar uma instÃ¢ncia de `RepetitionInfo`.

    @DisplayName("deve suportar 5 valores")
    @RepeatedTest(value = 5, name = "repetiÃ§Ã£o {currentRepetition}/ {totalRepetitions}")
    void deveSuportar5Valores(RepetitionInfo repetitionInfo) {
        lista.add("valor " + repetitionInfo.getCurrentRepetition())
    }

Existem muitos outros exemplos na [documentaÃ§Ã£o oficial](http://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests-examples).

### Testes ParametrizÃ¡veis
Testes parametrizÃ¡veis sÃ£o testes que podem receber valores como argumentos. Estes testes sÃ£o anotados com `@ParameterizedTest` e uma anotaÃ§Ã£o indicando a fonte de dados como, por exemplo, `@ValueSource` onde, esta segunda anotaÃ§Ã£o, indica os valores que serÃ£o passados como argumento para o teste.

    @ParameterizedTest
    @ValueSource(strings = { "Hello", "World" })
    void testWithStringParameter(String argument) {
        assertNotNull(argument);
    }

Para utilizar estes testes, Ã© necessÃ¡rio adicionar o mÃ³dulo `junit-jupiter-params` como dependencia.

    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-params</artifactId>
        <version>5.0.0</version>
        <scope>test</scope>
    </dependency>

Existem diversos sources de valores:

- @ValueSource
- @EnumSource
- @MethodSource
- @CsvSource
- @CsvFileSource
- @ArgumentsSource

Um dos mais utilizados,`@MethodSource`, recebe o nome de um mÃ©todo presente na classe de teste. Este mÃ©todo deve ser estÃ¡tico a nÃ£o ser que a classe esteja anotada com `@TestInstance(Lifecycle.PER_CLASS)`. O retorno deste mÃ©todo deve ser um `Stream`, `Iterable`, `Iterator`, ou array.

    @ParameterizedTest
    @MethodSource("stringProvider")
    void testWithSimpleMethodSource(String argument) {
        assertNotNull(argument);
    }

    static Stream<String> stringProvider() {
        return Stream.of("foo", "bar");
    }

Sobre os demais, consulte a [documentaÃ§Ã£o](http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources)

Ã‰ possÃ­vel definir o nome de exibiÃ§Ã£o dos testes parametrÃ­zÃ¡veis:

    @DisplayName("Display name of container")
    @ParameterizedTest(name = "{index} ==> first=''{0}'', second={1}    ")
    @CsvSource({ "foo, 1", "bar, 2", "'baz, qux', 3" })
    void testWithCustomDisplayNames(String first, int second) { }

Os valores `{0}` e `{1}` sÃ£o o Ã­ndice do argumento recebido pelo mÃ©todo.

    Display name of container âœ”
    â”œâ”€ 1 ==> first='foo', second=1 âœ”
    â”œâ”€ 2 ==> first='bar', second=2 âœ”
    â””â”€ 3 ==> first='baz, qux', second=3 âœ”

Veja mais na [documentaÃ§Ã£o](http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-display-names).

### Test Templates
A nova versÃ£o do JUnit inclui um tipo inteiramente novo de testes: testes dinÃ¢micos. Estes testes sÃ£o gerados totalmente em tempo de execuÃ§Ã£o e possuem estrutura diferente da usual. Estes testes sÃ£o criados por TestFactories.

Os testes dinÃ¢micos devem retornar um `Stream`, `Collection` , `Iterable`, `Iterator` de `DynamicNode`. O tipo `DynamicNode` possui duas sublcasses instanciÃ¡veis: `DynamicContainer` e `DynamicTest`.

Um `DynamicContainer` Ã© composto de um Display Name e uma lista de nÃ³s filho, possibilitando a criaÃ§Ã£o de hierarquias de nÃ³s dinÃ¢micos.

Um `DynamicTest` Ã© um caso de testes gerado em tempo de execuÃ§Ã£o e Ã© composto de display name e um `Executable`. Um `Executable` Ã© uma interface funcional, o que significa que podemos construir testes dinÃ¢micos com lambdas.

*Nota*: este Ã© um recurso experimental.

    class DynamicTestsDemo {

        // Vai resultar em um erro pois o tipo de retorno Ã© invÃ¡lido!
        @TestFactory
        List<String> dynamicTestsWithInvalidReturnType() {
            return Arrays.asList("Hello");
        }

        @TestFactory
        Collection<DynamicTest> dynamicTestsFromCollection() {
            return Arrays.asList(
                dynamicTest("1st dynamic test", () -> assertTrue    (true)),
                dynamicTest("2nd dynamic test", () -> assertEquals  (4, 2 * 2))
            );
        }

        @TestFactory
        Iterable<DynamicTest> dynamicTestsFromIterable() {
            return Arrays.asList(
                dynamicTest("3rd dynamic test", () -> assertTrue    (true)),
                dynamicTest("4th dynamic test", () -> assertEquals  (4, 2 * 2))
            );
        }

        // More tests

    }

Mais exemplos na [documentaÃ§Ã£o](http://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests-examples)
